---
import type { ContainerProps } from '~/types/container.types';
import Background from '~/components/blocks/Background.astro';

type Props = ContainerProps;

const props = Astro.props;
const ContainerTag = props.htmlTag ?? 'section';
const containerWidthType = props.containerWidthType ?? 'full';
const contentWidthType = props.content?.widthType ?? 'boxed';
const contentBoxWidth = props.content?.boxWidth ?? 'max-w-[var(--container-max-width)]';
const widthClass = props.width ?? '';
const minHeightClass = props.minHeight ?? '';
const items = props.items ?? [];
const equalHeight = props.equalHeight ?? false;
const overflow = props.overflow ?? undefined;
const containerClassName = props.containerClass ?? '';
const contentClassName = props.content?.class ?? '';

const layoutType = props.layout?.type ?? '';
const layoutClass = props.layout?.class ?? '';

// Check if there's a background
const hasBackground = !!props.background || Astro.slots.has('background');

// Build container classes
let containerClass = '';
if (containerWidthType === 'boxed') {
  containerClass += 'mx-auto max-w-[var(--container-max-width)] ';
} else if (containerWidthType === 'custom') {
  containerClass += 'mx-auto ';
}
if (widthClass) {
  containerClass += `${widthClass} `;
}
if (minHeightClass) {
  containerClass += `${minHeightClass} `;
}
if (overflow) {
  containerClass += ` overflow-${overflow}`;
}
if (props.spacing?.padding) {
  containerClass += ` ${props.spacing.padding}`;
}
if (props.spacing?.margin) {
  containerClass += ` ${props.spacing.margin}`;
}
if (props.spacing?.gap) {
  containerClass += ` ${props.spacing.gap}`;
}
if (props.border?.width) {
  containerClass += ` ${props.border.width}`;
}
if (props.border?.color) {
  containerClass += ` ${props.border.color}`;
}
if (props.border?.radius) {
  containerClass += ` ${props.border.radius}`;
}
if (containerClassName) {
  containerClass += ` ${containerClassName}`;
}

// Add relative positioning if there's a background
if (hasBackground) {
  containerClass = 'relative ' + containerClass;
}

const containerStyle = hasBackground ? 'position:relative;' : '';

let contentClass = 'w-full relative z-1';
if (layoutType) {
  contentClass += ` ${layoutType}`;
}
if (layoutClass) {
  contentClass += ` ${layoutClass}`;
}
if (containerWidthType === 'full') {
  if (contentWidthType === 'boxed') {
    contentClass += ` ${contentBoxWidth} mx-auto`;
    // Apply min-height to content div when container is full-width and content is boxed
    if (minHeightClass) {
      contentClass += ` ${minHeightClass}`;
    }
  } else if (contentWidthType === 'full') {
    contentClass += ' w-full';
  }
}
if (props.content?.spacing?.padding) {
  contentClass += ` ${props.content.spacing.padding}`;
}
if (props.content?.spacing?.margin) {
  contentClass += ` ${props.content.spacing.margin}`;
}
if (props.content?.spacing?.gap) {
  contentClass += ` ${props.content.spacing.gap}`;
}
if (props.content?.border?.width) {
  contentClass += ` ${props.content.border.width}`;
}
if (props.content?.border?.color) {
  contentClass += ` ${props.content.border.color}`;
}
if (props.content?.border?.radius) {
  contentClass += ` ${props.content.border.radius}`;
}
if (contentClassName) {
  contentClass += ` ${contentClassName}`;
}
if (equalHeight) {
  contentClass += ' items-stretch';
}
---

<ContainerTag class={containerClass.trim()} style={containerStyle}>
  {
    Astro.slots.background ? (
      <slot name="background" />
    ) : props.background ? (
      <Background
        image={props.background.image}
        video={props.background.video}
        attachment={props.background.attachment}
        class={props.background.class}
      />
    ) : null
  }
  <div class={contentClass.trim()}>
    {
      items && items.length > 0 ? (
        items.map((item) => <div class={item.class} id={item.id} set:html={item.content} />)
      ) : (
        <slot />
      )
    }
  </div>
</ContainerTag>
